<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng ƒê·ªì th·ªã (Ho√†n ch·ªânh)</title>
    
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; }
        header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
        h1 { font-size: 2.5em; margin-bottom: 10px; }
        .subtitle { font-size: 1.1em; opacity: 0.9; }
        .main-content { display: grid; grid-template-columns: 350px 1fr; gap: 20px; padding: 20px; }
        .sidebar { background: #f8f9fa; border-radius: 15px; padding: 20px; height: fit-content; max-height: calc(100vh - 200px); overflow-y: auto; }
        .section { margin-bottom: 25px; background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .section h3 { color: #667eea; margin-bottom: 15px; font-size: 1.2em; border-bottom: 2px solid #667eea; padding-bottom: 10px; }
        .input-group { margin-bottom: 12px; }
        label { display: block; margin-bottom: 5px; color: #555; font-weight: 600; font-size: 0.9em; }
        input[type="text"], input[type="number"], input[type="file"] { width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; transition: border-color 0.3s; }
        input[type="text"]:focus, input[type="number"]:focus { outline: none; border-color: #667eea; }
        input[type="range"] { width: 100%; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin: 10px 0; }
        input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        button { width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; margin-bottom: 8px; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .btn-secondary { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .btn-success { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .btn-danger { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .btn-warning { background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%); color: #333; }
        .btn-info { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333; }
        .graph-container { background: white; border-radius: 15px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        #mynetwork { height: 600px; border: 3px solid #e0e0e0; border-radius: 10px; background: #fafafa; }
        .result-box { margin-top: 20px; padding: 15px; background: #f0f7ff; border-left: 4px solid #667eea; border-radius: 8px; display: none; }
        .result-box.show { display: block; animation: slideIn 0.3s ease-out; }
        .result-box.error { background: #fff5f5; border-left-color: #f5576c; }
        .result-box.success { background: #f0fff4; border-left-color: #00f2fe; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .result-title { font-weight: 600; color: #667eea; margin-bottom: 10px; font-size: 1.1em; }
        .result-content { color: #333; line-height: 1.6; white-space: pre-wrap; font-family: monospace; max-height: 400px; overflow-y: auto; }
        .algorithm-buttons, .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .algorithm-buttons button { font-size: 13px; padding: 10px; }
        .speed-control { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .speed-value { font-weight: bold; color: #667eea; min-width: 50px; text-align: right; }
        select { width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; margin-bottom: 10px; }
        @media (max-width: 1024px) { .main-content { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî∑ ·ª®ng d·ª•ng ƒê·ªì th·ªã</h1>
            <p class="subtitle">C√¥ng c·ª• tr·ª±c quan h√≥a v√† x·ª≠ l√Ω ƒë·ªì th·ªã - Ho√†n ch·ªânh ‚úÖ</p>
        </header>

        <div class="main-content">
            <div class="sidebar">
                <div class="section">
                    <h3>üì• Import/Export</h3>
                    <input type="file" id="importFile" accept=".json" style="margin-bottom: 10px;">
                    <button class="btn-success" onclick="importGraph()">üìÇ Import JSON</button>
                    <button class="btn-info" onclick="exportGraph()">üíæ Export JSON</button>
                </div>

                <div class="section">
                    <h3>‚öôÔ∏è T·ªëc ƒë·ªô Animation</h3>
                    <div class="speed-control">
                        <label style="margin: 0;">Nhanh</label>
                        <input type="range" id="speedSlider" min="100" max="2000" value="600" step="100">
                        <label style="margin: 0;">Ch·∫≠m</label>
                    </div>
                    <div style="text-align: center; margin-top: 8px;">
                        <span class="speed-value"><span id="speedValue">600</span>ms</span>
                    </div>
                </div>

                <div class="section">
                    <h3>1. Th√™m ƒê·ªânh</h3>
                    <div class="input-group">
                        <label>T√™n ƒë·ªânh:</label>
                        <input type="text" id="vertexName" placeholder="V√≠ d·ª•: A">
                    </div>
                    <button onclick="addVertex()">‚ûï Th√™m ƒê·ªânh</button>
                </div>

                <div class="section">
                    <h3>2. Th√™m C·∫°nh</h3>
                    <div class="input-group">
                        <label>T·ª´ ƒë·ªânh:</label>
                        <input type="text" id="fromVertex" placeholder="V√≠ d·ª•: A">
                    </div>
                    <div class="input-group">
                        <label>ƒê·∫øn ƒë·ªânh:</label>
                        <input type="text" id="toVertex" placeholder="V√≠ d·ª•: B">
                    </div>
                    <div class="input-group">
                        <label>Tr·ªçng s·ªë:</label>
                        <input type="number" id="weight" placeholder = "V√≠ d·ª•: 5">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="directed">
                        <label for="directed">C√≥ h∆∞·ªõng (M≈©i t√™n)</label>
                    </div>
                    <button onclick="addEdge()">Th√™m C·∫°nh</button>
                </div>

                <div class="section">
                    <h3>3. L∆∞u & Qu·∫£n l√Ω</h3>
                    <button class="btn-danger" onclick="clearGraph()">X√≥a To√†n B·ªô</button>
                </div>

                <div class="section">
                    <h3>üí° H∆∞·ªõng d·∫´n</h3>
                    <div style="background: #f0f7ff; padding: 10px; border-radius: 8px; font-size: 13px; line-height: 1.6;">
                        <strong>X√≥a ƒë·ªânh/c·∫°nh:</strong><br>
                        1. Click ch·ªçn ƒë·ªânh ho·∫∑c c·∫°nh<br>
                        2. Nh·∫•n ph√≠m <kbd>Delete</kbd> ho·∫∑c <kbd>Backspace</kbd><br>
                        <em style="color: #666;">* X√≥a ƒë·ªânh s·∫Ω x√≥a lu√¥n c√°c c·∫°nh li√™n quan</em>
                    </div>
                </div>

                <div class="section">
                    <h3>4. Duy·ªát ƒê·ªì Th·ªã</h3>
                    <div class="input-group">
                        <label>ƒê·ªânh b·∫Øt ƒë·∫ßu:</label>
                        <input type="text" id="startVertex" placeholder="V√≠ d·ª•: A">
                    </div>
                    <div class="grid-2">
                        <button class="btn-secondary" onclick="runBFS()">BFS</button>
                        <button class="btn-secondary" onclick="runDFS()">DFS</button>
                    </div>
                </div>

                <div class="section">
                    <h3>5. T√¨m ƒê∆∞·ªùng ƒêi</h3>
                    <div class="input-group">
                        <label>T·ª´ ƒë·ªânh:</label>
                        <input type="text" id="dijkstraStart" placeholder="V√≠ d·ª•: A">
                    </div>
                    <div class="input-group">
                        <label>ƒê·∫øn ƒë·ªânh:</label>
                        <input type="text" id="dijkstraEnd" placeholder="V√≠ d·ª•: E">
                    </div>
                    <button class="btn-success" onclick="runDijkstra()">Dijkstra</button>
                </div>
                
                <div class="section">
                    <h3>6. Thu·∫≠t To√°n Kh√°c</h3>
                    <div class="algorithm-buttons">
                        <button class="btn-success" onclick="runPrim()">Prim (MST)</button>
                        <button class="btn-success" onclick="runKruskal()">Kruskal (MST)</button>
                        <button class="btn-info" onclick="checkBipartite()">Check 2 Ph√≠a</button>
                    </div>
                </div>

                 <div class="section">
                    <h3>7. Lu·ªìng & Euler</h3>
                     <div class="input-group">
                        <label>Ngu·ªìn/ƒê√≠ch (Flow):</label>
                        <div style="display: flex; gap: 5px;">
                             <input type="text" id="flowSource" placeholder="S">
                             <input type="text" id="flowSink" placeholder="T">
                        </div>
                    </div>
                    <button class="btn-warning" onclick="runFordFulkerson()">Ford-Fulkerson</button>
                    
                     <div class="input-group" style="margin-top: 10px;">
                        <label>ƒê·ªânh Euler:</label>
                        <input type="text" id="eulerStart" placeholder="V√≠ d·ª•: A">
                    </div>
                    <div class="grid-2">
                        <button class="btn-info" onclick="runFleury()">Fleury</button>
                        <button class="btn-info" onclick="runHierholzer()">Hierholzer</button>
                    </div>
                </div>

                <div class="section">
                    <h3>8. Chuy·ªÉn ƒë·ªïi bi·ªÉu di·ªÖn</h3>
                    <select id="convertType">
                        <option value="adjacency_list">Danh s√°ch k·ªÅ</option>
                        <option value="adjacency_matrix">Ma tr·∫≠n k·ªÅ</option>
                        <option value="edge_list">Danh s√°ch c·∫°nh</option>
                    </select>
                    <button class="btn-info" onclick="convertGraph()">Chuy·ªÉn ƒë·ªïi</button>
                </div>
            </div>

            <div class="graph-container">
                <div id="mynetwork"></div>
                <div id="result" class="result-box">
                    <div class="result-title">K·∫øt qu·∫£:</div>
                    <div class="result-content" id="resultContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let network;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let animationSpeed = 600; // T·ªëc ƒë·ªô m·∫∑c ƒë·ªãnh

        // C·∫≠p nh·∫≠t t·ªëc ƒë·ªô khi slider thay ƒë·ªïi
        document.getElementById('speedSlider').addEventListener('input', function(e) {
            animationSpeed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed;
        });

        function initNetwork() {
            const container = document.getElementById('mynetwork');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'circle',
                    size: 30,
                    font: { size: 16, color: '#ffffff' },
                    color: { background: '#667eea', border: '#764ba2', highlight: { background: '#f093fb', border: '#f5576c' } },
                    borderWidth: 2
                },
                edges: {
                    width: 2,
                    color: { color: '#848484', highlight: '#f5576c' },
                    arrows: { to: { enabled: true, scaleFactor: 1 } },
                    font: { size: 14, align: 'top', background: 'white' },
                    smooth: { type: 'continuous' }
                },
                physics: {
                    enabled: false,
                    barnesHut: { gravitationalConstant: -2000, springLength: 200 }
                },
                manipulation: {
                    enabled: false
                }
            };
            network = new vis.Network(container, data, options);
            
            // Th√™m event listener cho ph√≠m Delete
            document.addEventListener('keydown', handleDeleteKey);
        }

        async function handleDeleteKey(event) {
            if (event.key === 'Delete' || event.key === 'Backspace') {
                const selection = network.getSelection();
                
                // X√≥a ƒë·ªânh
                if (selection.nodes.length > 0) {
                    const nodeId = selection.nodes[0];
                    if (confirm(`X√≥a ƒë·ªânh "${nodeId}" v√† t·∫•t c·∫£ c√°c c·∫°nh li√™n quan?`)) {
                        try {
                            const data = await fetchWithErrorHandling('/api/delete_vertex', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ vertex: nodeId })
                            });
                            
                            if (data.success) {
                                updateGraph(data.graph);
                                showResult(`‚úÖ ƒê√£ x√≥a ƒë·ªânh: ${nodeId}`, 'success');
                            }
                        } catch (error) {
                            showResult('L·ªói x√≥a ƒë·ªânh: ' + error.message, 'error');
                        }
                    }
                }
                // X√≥a c·∫°nh
                else if (selection.edges.length > 0) {
                    const edgeId = selection.edges[0];
                    const edge = edges.get(edgeId);
                    
                    if (edge && confirm(`X√≥a c·∫°nh "${edgeId}"?`)) {
                        try {
                            // X√°c ƒë·ªãnh xem c·∫°nh c√≥ h∆∞·ªõng hay kh√¥ng
                            const directed = edge.arrows === 'to';
                            
                            const data = await fetchWithErrorHandling('/api/delete_edge', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    from: edge.from, 
                                    to: edge.to,
                                    directed: directed
                                })
                            });
                            
                            if (data.success) {
                                updateGraph(data.graph);
                                showResult(`‚úÖ ƒê√£ x√≥a c·∫°nh: ${edgeId}`, 'success');
                            }
                        } catch (error) {
                            showResult('L·ªói x√≥a c·∫°nh: ' + error.message, 'error');
                        }
                    }
                }
            }
        }



        function updateGraph(graphData) {
            if (graphData.nodes) {
                let currentIds = nodes.getIds();
                let newIds = graphData.nodes.map(n => n.id);
                nodes.remove(currentIds.filter(id => !newIds.includes(id)));
                nodes.update(graphData.nodes);
            }
            
            if (graphData.edges) {
                let currentEdgeIds = edges.getIds();
                let newEdgeIds = graphData.edges.map(e => e.id);
                edges.remove(currentEdgeIds.filter(id => !newEdgeIds.includes(id)));
                
                const processedEdges = graphData.edges.map(edge => ({
                    id: edge.id,
                    from: edge.from,
                    to: edge.to,
                    label: edge.label,
                    arrows: edge.arrows 
                }));
                edges.update(processedEdges);
            }
        }

        function showResult(message, type = 'info') {
            const resultBox = document.getElementById('result');
            const resultContent = document.getElementById('resultContent');
            resultBox.className = 'result-box show ' + type;
            resultContent.innerHTML = message;
            setTimeout(() => { 
                if(resultBox.classList.contains('show')) resultBox.classList.remove('show'); 
            }, 60000);
        }

        async function fetchWithErrorHandling(url, options = {}) {
            try {
                const response = await fetch(url, options);
                const data = await response.json();
                if (!response.ok) throw new Error(data.message || 'L·ªói server');
                return data;
            } catch (error) {
                showResult(`L·ªói: ${error.message}`, 'error');
                throw error;
            }
        }

        // === IMPORT/EXPORT ===
        async function importGraph() {
            const fileInput = document.getElementById('importFile');
            const file = fileInput.files[0];
            
            if (!file) {
                return showResult('Vui l√≤ng ch·ªçn file JSON!', 'error');
            }

            try {
                const text = await file.text();
                const jsonData = JSON.parse(text);
                
                const data = await fetchWithErrorHandling('/api/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(jsonData)
                });

                if (data.success) {
                    updateGraph(data.graph);
                    showResult('‚úÖ Import th√†nh c√¥ng!', 'success');
                    fileInput.value = '';
                }
            } catch (error) {
                showResult('L·ªói ƒë·ªçc file: ' + error.message, 'error');
            }
        }

        async function exportGraph() {
            try {
                const data = await fetchWithErrorHandling('/api/export');
                
                // T·∫°o file JSON v√† t·∫£i xu·ªëng
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'graph_export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showResult('‚úÖ Export th√†nh c√¥ng! File ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng.', 'success');
            } catch (error) {
                showResult('L·ªói export: ' + error.message, 'error');
            }
        }

        async function convertGraph() {
            const convertType = document.getElementById('convertType').value;
            
            try {
                const data = await fetchWithErrorHandling('/api/convert', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: convertType })
                });

                let message = '';
                if (convertType === 'adjacency_list') {
                    message = '<strong>üìã Danh s√°ch k·ªÅ:</strong><br><br>';
                    for (let vertex in data.result) {
                        const neighbors = data.result[vertex];
                        message += `${vertex}: ${neighbors.length > 0 ? neighbors.join(', ') : '(kh√¥ng c√≥ k·ªÅ)'}<br>`;
                    }
                } else if (convertType === 'adjacency_matrix') {
                    message = '<strong>üî¢ Ma tr·∫≠n k·ªÅ:</strong><br>ƒê·ªânh: ' + data.result.vertices.join(', ') + '<br><br>';
                    data.result.matrix.forEach((row, i) => {
                        message += data.result.vertices[i] + ': [' + row.join(', ') + ']<br>';
                    });
                } else if (convertType === 'edge_list') {
                    message = '<strong>üìù Danh s√°ch c·∫°nh:</strong><br><br>';
                    message += data.result.join('<br>');
                }
                
                showResult(message, 'info');
            } catch (error) {
                showResult('L·ªói chuy·ªÉn ƒë·ªïi: ' + error.message, 'error');
            }
        }

        // === C√ÅC H√ÄM C≈® ===
        async function addVertex() {
            const vertex = document.getElementById('vertexName').value.trim();
            if (!vertex) return showResult('Vui l√≤ng nh·∫≠p t√™n ƒë·ªânh!', 'error');

            const data = await fetchWithErrorHandling('/api/add_vertex', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ vertex })
            });

            if (data.success) {
                updateGraph(data.graph);
                showResult(`‚úÖ ƒê√£ th√™m ƒë·ªânh: ${vertex}`, 'success');
                document.getElementById('vertexName').value = '';
            }
        }

        async function addEdge() {
            const from = document.getElementById('fromVertex').value.trim();
            const to = document.getElementById('toVertex').value.trim();
            const weightInput = document.getElementById('weight').value;
            // THAY ƒê·ªîI: N·∫øu kh√¥ng nh·∫≠p weight th√¨ ƒë·ªÉ tr·ªëng (backend s·∫Ω set = 0)
            const weight = weightInput !== '' ? weightInput : '';
            const directed = document.getElementById('directed').checked;

            if (!from || !to) return showResult('Vui l√≤ng nh·∫≠p c·∫£ hai ƒë·ªânh!', 'error');

            const data = await fetchWithErrorHandling('/api/add_edge', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ from, to, weight, directed })
            });

            if (data.success) {
                updateGraph(data.graph);
                showResult(`ƒê√£ th√™m c·∫°nh ${from} ${directed ? '‚Üí' : '-'} ${to}`, 'success');
                // Clear form sau khi th√™m th√†nh c√¥ng
                document.getElementById('weight').value = '';
            }
        }

        async function clearGraph() {
            if (confirm('X√≥a to√†n b·ªô ƒë·ªì th·ªã?')) {
                await fetchWithErrorHandling('/api/clear', { method: 'POST' });
                nodes.clear();
                edges.clear();
                showResult('ƒê√£ reset ƒë·ªì th·ªã', 'success');
            }
        }

        async function runBFS() {
            const start = document.getElementById('startVertex').value.trim();
            if(!start) return showResult('Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu', 'error');
            const data = await fetchWithErrorHandling('/api/bfs', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start })
            });
            showResult(`BFS: ${data.order.join(' ‚Üí ')}`, 'success');
            await animateEdges(data.edges);
        }
        
        async function runDFS() {
            const start = document.getElementById('startVertex').value.trim();
            if(!start) return showResult('Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu', 'error');
            const data = await fetchWithErrorHandling('/api/dfs', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start })
            });
            showResult(`DFS: ${data.order.join(' ‚Üí ')}`, 'success');
            await animateEdges(data.edges);
        }

        async function runDijkstra() {
            const start = document.getElementById('dijkstraStart').value.trim();
            const end = document.getElementById('dijkstraEnd').value.trim();
            if(!start || !end) return showResult('Nh·∫≠p ƒë·ªânh ngu·ªìn v√† ƒë√≠ch', 'error');
            
            const data = await fetchWithErrorHandling('/api/dijkstra', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start, end })
            });
            
            if(data.error) {
                showResult(`‚ö†Ô∏è ${data.error}`, 'error');
                return;
            }
            
            if(data.path) {
                showResult(`Dijkstra (${data.distance}): ${data.path.join(' ‚Üí ')}`, 'success');
                await animateEdges(data.edges);
            } else {
                showResult('Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng ƒëi', 'error');
            }
        }

        async function runPrim() {
            try {
                const data = await fetchWithErrorHandling('/api/prim');
                // TH√äM: Ki·ªÉm tra l·ªói t·ª´ backend
                if (data.success === false) {
                    showResult(`‚ö†Ô∏è ${data.message}`, 'error');
                    return;
                }
                showResult(`Prim (T·ªïng ${data.total_weight})`, 'success');
                await animateEdges(data.edges_used.map(e => [e[0], e[1]]));
            } catch (error) {
                showResult('L·ªói: ' + error.message, 'error');
            }
        }

        async function runKruskal() {
            try {
                const data = await fetchWithErrorHandling('/api/kruskal');
                // TH√äM: Ki·ªÉm tra l·ªói t·ª´ backend
                if (data.success === false) {
                    showResult(`‚ö†Ô∏è ${data.message}`, 'error');
                    return;
                }
                showResult(`Kruskal (T·ªïng ${data.total_weight})`, 'success');
                await animateEdges(data.edges_used.map(e => [e[0], e[1]]));
            } catch (error) {
                showResult('L·ªói: ' + error.message, 'error');
            }
        }
        
        async function runFordFulkerson() {
             const source = document.getElementById('flowSource').value.trim();
             const sink = document.getElementById('flowSink').value.trim();
             if(!source || !sink) return showResult('Nh·∫≠p ngu·ªìn v√† ƒë√≠ch', 'error');
             
             const data = await fetchWithErrorHandling('/api/ford_fulkerson', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ source, sink })
            });
            
            if(data.success) {
                showResult(`Lu·ªìng c·ª±c ƒë·∫°i: ${data.max_flow}`, 'success');
                const allEdges = data.paths.flatMap(p => p.path);
                await animateEdges(allEdges);
            }
        }

        async function runFleury() {
            const start = document.getElementById('eulerStart').value.trim();
            if(!start) return showResult('Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu', 'error');
            const data = await fetchWithErrorHandling('/api/fleury', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start })
            });
            if(data.success) {
                showResult(`Euler (Fleury): ${data.path.join(' ‚Üí ')}`, 'success');
                await animateEdges(data.edges);
            } else {
                showResult(data.message, 'error');
            }
        }
        
        async function runHierholzer() {
            const start = document.getElementById('eulerStart').value.trim();
            if(!start) return showResult('Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu', 'error');
            const data = await fetchWithErrorHandling('/api/hierholzer', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start })
            });
            if(data.success) {
                showResult(`Euler (Hierholzer): ${data.path.join(' ‚Üí ')}`, 'success');
                await animateEdges(data.edges);
            } else {
                showResult(data.message, 'error');
            }
        }
        
        async function checkBipartite() {
            const v = nodes.getIds()[0];
            const data = await fetchWithErrorHandling('/api/check_bipartite', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ vertex: v })
            });
            showResult(data.message, data.is_bipartite ? 'success' : 'error');
        }

        async function animateEdges(edgeList) {
            const allEdges = edges.get();
            allEdges.forEach(e => edges.update({id: e.id, color: {color: '#848484'}, width: 2}));

            for (let i = 0; i < edgeList.length; i++) {
                await new Promise(r => setTimeout(r, animationSpeed));
                
                const [u, v] = edgeList[i];
                let id = `${u}->${v}`;
                let item = edges.get(id);
                
                if (!item) {
                    const sorted = [u, v].sort();
                    id = `${sorted[0]}-${sorted[1]}`;
                    item = edges.get(id);
                }

                if (item) {
                    edges.update({ id: id, color: { color: '#f5576c' }, width: 4 });
                }
            }
        }

        async function loadGraph() {
            try {
                const data = await fetchWithErrorHandling('/api/graph');
                updateGraph(data);
            } catch(e) { console.log("Ch∆∞a c√≥ data"); }
        }
        
        initNetwork();
        loadGraph();
    </script>
</body>
</html>